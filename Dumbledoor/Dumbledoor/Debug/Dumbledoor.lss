
Dumbledoor.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000016e  00800100  00000dd6  00000e6a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000010e  0080026e  0080026e  00000fd8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fd8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001008  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00001048  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000274c  00000000  00000000  000011f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d25  00000000  00000000  0000393c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000125f  00000000  00000000  00004661  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004b0  00000000  00000000  000058c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007c3  00000000  00000000  00005d70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001307  00000000  00000000  00006533  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001a8  00000000  00000000  0000783a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 7e 02 	jmp	0x4fc	; 0x4fc <__vector_9>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 fb 01 	jmp	0x3f6	; 0x3f6 <__vector_13>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 70 05 	jmp	0xae0	; 0xae0 <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 1f 06 	jmp	0xc3e	; 0xc3e <__vector_18>
  4c:	0c 94 4d 06 	jmp	0xc9a	; 0xc9a <__vector_19>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	12 e0       	ldi	r17, 0x02	; 2
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e6 ed       	ldi	r30, 0xD6	; 214
  7c:	fd e0       	ldi	r31, 0x0D	; 13
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 36       	cpi	r26, 0x6E	; 110
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	23 e0       	ldi	r18, 0x03	; 3
  8c:	ae e6       	ldi	r26, 0x6E	; 110
  8e:	b2 e0       	ldi	r27, 0x02	; 2
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ac 37       	cpi	r26, 0x7C	; 124
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 d5 03 	call	0x7aa	; 0x7aa <main>
  9e:	0c 94 e9 06 	jmp	0xdd2	; 0xdd2 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <GPIO_config_output>:
  a6:	fc 01       	movw	r30, r24
  a8:	40 81       	ld	r20, Z
  aa:	21 e0       	ldi	r18, 0x01	; 1
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <GPIO_config_output+0xe>
  b0:	22 0f       	add	r18, r18
  b2:	33 1f       	adc	r19, r19
  b4:	6a 95       	dec	r22
  b6:	e2 f7       	brpl	.-8      	; 0xb0 <GPIO_config_output+0xa>
  b8:	24 2b       	or	r18, r20
  ba:	20 83       	st	Z, r18
  bc:	08 95       	ret

000000be <GPIO_config_input_pullup>:
  be:	fc 01       	movw	r30, r24
  c0:	80 81       	ld	r24, Z
  c2:	21 e0       	ldi	r18, 0x01	; 1
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	02 c0       	rjmp	.+4      	; 0xcc <GPIO_config_input_pullup+0xe>
  c8:	22 0f       	add	r18, r18
  ca:	33 1f       	adc	r19, r19
  cc:	6a 95       	dec	r22
  ce:	e2 f7       	brpl	.-8      	; 0xc8 <GPIO_config_input_pullup+0xa>
  d0:	92 2f       	mov	r25, r18
  d2:	90 95       	com	r25
  d4:	89 23       	and	r24, r25
  d6:	80 83       	st	Z, r24
  d8:	80 81       	ld	r24, Z
  da:	81 81       	ldd	r24, Z+1	; 0x01
  dc:	28 2b       	or	r18, r24
  de:	21 83       	std	Z+1, r18	; 0x01
  e0:	08 95       	ret

000000e2 <GPIO_write_low>:
  e2:	fc 01       	movw	r30, r24
  e4:	90 81       	ld	r25, Z
  e6:	21 e0       	ldi	r18, 0x01	; 1
  e8:	30 e0       	ldi	r19, 0x00	; 0
  ea:	02 c0       	rjmp	.+4      	; 0xf0 <GPIO_write_low+0xe>
  ec:	22 0f       	add	r18, r18
  ee:	33 1f       	adc	r19, r19
  f0:	6a 95       	dec	r22
  f2:	e2 f7       	brpl	.-8      	; 0xec <GPIO_write_low+0xa>
  f4:	20 95       	com	r18
  f6:	29 23       	and	r18, r25
  f8:	20 83       	st	Z, r18
  fa:	08 95       	ret

000000fc <GPIO_write_high>:
  fc:	fc 01       	movw	r30, r24
  fe:	40 81       	ld	r20, Z
 100:	21 e0       	ldi	r18, 0x01	; 1
 102:	30 e0       	ldi	r19, 0x00	; 0
 104:	02 c0       	rjmp	.+4      	; 0x10a <GPIO_write_high+0xe>
 106:	22 0f       	add	r18, r18
 108:	33 1f       	adc	r19, r19
 10a:	6a 95       	dec	r22
 10c:	e2 f7       	brpl	.-8      	; 0x106 <GPIO_write_high+0xa>
 10e:	24 2b       	or	r18, r20
 110:	20 83       	st	Z, r18
 112:	08 95       	ret

00000114 <GPIO_toggle>:
 114:	fc 01       	movw	r30, r24
 116:	40 81       	ld	r20, Z
 118:	21 e0       	ldi	r18, 0x01	; 1
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	02 c0       	rjmp	.+4      	; 0x122 <GPIO_toggle+0xe>
 11e:	22 0f       	add	r18, r18
 120:	33 1f       	adc	r19, r19
 122:	6a 95       	dec	r22
 124:	e2 f7       	brpl	.-8      	; 0x11e <GPIO_toggle+0xa>
 126:	24 27       	eor	r18, r20
 128:	20 83       	st	Z, r18
 12a:	08 95       	ret

0000012c <GPIO_read>:
 12c:	fc 01       	movw	r30, r24
 12e:	80 81       	ld	r24, Z
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	02 c0       	rjmp	.+4      	; 0x138 <GPIO_read+0xc>
 134:	95 95       	asr	r25
 136:	87 95       	ror	r24
 138:	6a 95       	dec	r22
 13a:	e2 f7       	brpl	.-8      	; 0x134 <GPIO_read+0x8>
 13c:	81 70       	andi	r24, 0x01	; 1
 13e:	08 95       	ret

00000140 <keypad_init>:
uint8_t columns[3] = {CN0,CN1,CN2};

/* Function definitions ----------------------------------------------*/
void keypad_init() {
	//Set all columns to output
	GPIO_config_output(&DDRC, CN0);
 140:	60 e0       	ldi	r22, 0x00	; 0
 142:	87 e2       	ldi	r24, 0x27	; 39
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_config_output(&DDRC, CN1);
 14a:	61 e0       	ldi	r22, 0x01	; 1
 14c:	87 e2       	ldi	r24, 0x27	; 39
 14e:	90 e0       	ldi	r25, 0x00	; 0
 150:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_config_output(&DDRC, CN2);
 154:	62 e0       	ldi	r22, 0x02	; 2
 156:	87 e2       	ldi	r24, 0x27	; 39
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	//Set all columns to high
	GPIO_write_high(&PORTC, CN0);
 15e:	60 e0       	ldi	r22, 0x00	; 0
 160:	88 e2       	ldi	r24, 0x28	; 40
 162:	90 e0       	ldi	r25, 0x00	; 0
 164:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	GPIO_write_high(&PORTC, CN1);
 168:	61 e0       	ldi	r22, 0x01	; 1
 16a:	88 e2       	ldi	r24, 0x28	; 40
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	GPIO_write_high(&PORTC, CN2);
 172:	62 e0       	ldi	r22, 0x02	; 2
 174:	88 e2       	ldi	r24, 0x28	; 40
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	
	//Set all rows to input with pull-up resistor
	GPIO_config_input_pullup(&DDRC, RN0);
 17c:	66 e0       	ldi	r22, 0x06	; 6
 17e:	87 e2       	ldi	r24, 0x27	; 39
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	GPIO_config_input_pullup(&DDRC, RN1);
 186:	65 e0       	ldi	r22, 0x05	; 5
 188:	87 e2       	ldi	r24, 0x27	; 39
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	GPIO_config_input_pullup(&DDRC, RN2);
 190:	64 e0       	ldi	r22, 0x04	; 4
 192:	87 e2       	ldi	r24, 0x27	; 39
 194:	90 e0       	ldi	r25, 0x00	; 0
 196:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
	GPIO_config_input_pullup(&DDRC, RN3);
 19a:	63 e0       	ldi	r22, 0x03	; 3
 19c:	87 e2       	ldi	r24, 0x27	; 39
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	0e 94 5f 00 	call	0xbe	; 0xbe <GPIO_config_input_pullup>
 1a4:	08 95       	ret

000001a6 <keypad_scan>:
}

/*--------------------------------------------------------------------*/
uint8_t keypad_scan() {
 1a6:	7f 92       	push	r7
 1a8:	8f 92       	push	r8
 1aa:	9f 92       	push	r9
 1ac:	af 92       	push	r10
 1ae:	bf 92       	push	r11
 1b0:	cf 92       	push	r12
 1b2:	df 92       	push	r13
 1b4:	ef 92       	push	r14
 1b6:	ff 92       	push	r15
 1b8:	0f 93       	push	r16
 1ba:	1f 93       	push	r17
 1bc:	cf 93       	push	r28
 1be:	df 93       	push	r29
 1c0:	0f 2e       	mov	r0, r31
 1c2:	f0 e0       	ldi	r31, 0x00	; 0
 1c4:	ef 2e       	mov	r14, r31
 1c6:	f1 e0       	ldi	r31, 0x01	; 1
 1c8:	ff 2e       	mov	r15, r31
 1ca:	f0 2d       	mov	r31, r0
 1cc:	0f 2e       	mov	r0, r31
 1ce:	f7 e0       	ldi	r31, 0x07	; 7
 1d0:	cf 2e       	mov	r12, r31
 1d2:	f1 e0       	ldi	r31, 0x01	; 1
 1d4:	df 2e       	mov	r13, r31
 1d6:	f0 2d       	mov	r31, r0
 1d8:	0f 2e       	mov	r0, r31
 1da:	f3 e0       	ldi	r31, 0x03	; 3
 1dc:	af 2e       	mov	r10, r31
 1de:	f1 e0       	ldi	r31, 0x01	; 1
 1e0:	bf 2e       	mov	r11, r31
 1e2:	f0 2d       	mov	r31, r0
	static uint8_t isKeyPressed = 0;
	uint8_t rowN = -1;          // Row Number
	uint8_t colN = -1;          // Column Number
	char pKey = ' ';            // Pressed Key
 1e4:	68 94       	set
 1e6:	77 24       	eor	r7, r7
 1e8:	75 f8       	bld	r7, 5
 1ea:	07 e0       	ldi	r16, 0x07	; 7
 1ec:	11 e0       	ldi	r17, 0x01	; 1
	
	for(uint8_t i = 0; i<3; i++)
	{
		
		//Set all columns to high
		GPIO_write_high(&PORTC, CN0);
 1ee:	60 e0       	ldi	r22, 0x00	; 0
 1f0:	88 e2       	ldi	r24, 0x28	; 40
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
		GPIO_write_high(&PORTC, CN1);
 1f8:	61 e0       	ldi	r22, 0x01	; 1
 1fa:	88 e2       	ldi	r24, 0x28	; 40
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
		GPIO_write_high(&PORTC, CN2);
 202:	62 e0       	ldi	r22, 0x02	; 2
 204:	88 e2       	ldi	r24, 0x28	; 40
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	
		// Make current column low and set the variable
		GPIO_write_low(&PORTC, columns[i]);
 20c:	f7 01       	movw	r30, r14
 20e:	61 91       	ld	r22, Z+
 210:	7f 01       	movw	r14, r30
 212:	88 e2       	ldi	r24, 0x28	; 40
 214:	90 e0       	ldi	r25, 0x00	; 0
 216:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
 21a:	0f 2e       	mov	r0, r31
 21c:	f3 e0       	ldi	r31, 0x03	; 3
 21e:	8f 2e       	mov	r8, r31
 220:	f1 e0       	ldi	r31, 0x01	; 1
 222:	9f 2e       	mov	r9, r31
 224:	f0 2d       	mov	r31, r0
 226:	e6 01       	movw	r28, r12
		// Check each row
		for(uint8_t j = 0; j<4; j++)
		{
			
			// If it is low the button is pressed (current row x low valued column)
			if(GPIO_read(&PINC, rows[j]) == 0)
 228:	f4 01       	movw	r30, r8
 22a:	61 91       	ld	r22, Z+
 22c:	4f 01       	movw	r8, r30
 22e:	86 e2       	ldi	r24, 0x26	; 38
 230:	90 e0       	ldi	r25, 0x00	; 0
 232:	0e 94 96 00 	call	0x12c	; 0x12c <GPIO_read>
 236:	81 11       	cpse	r24, r1
 238:	01 c0       	rjmp	.+2      	; 0x23c <keypad_scan+0x96>
			{
				rowN = j;
				// From the row and column number get the pressed key
				pKey = keyPadChar[rowN][colN];
 23a:	78 80       	ld	r7, Y
 23c:	23 96       	adiw	r28, 0x03	; 3
		// Make current column low and set the variable
		GPIO_write_low(&PORTC, columns[i]);
		colN = i;
		
		// Check each row
		for(uint8_t j = 0; j<4; j++)
 23e:	80 16       	cp	r8, r16
 240:	91 06       	cpc	r9, r17
 242:	91 f7       	brne	.-28     	; 0x228 <keypad_scan+0x82>
				pKey = keyPadChar[rowN][colN];
			}
		}
		
		// If a key pressed stop the current scanning cycle
		if(pKey != ' ')
 244:	f0 e2       	ldi	r31, 0x20	; 32
 246:	7f 12       	cpse	r7, r31
 248:	0c c0       	rjmp	.+24     	; 0x262 <keypad_scan+0xbc>
 24a:	8f ef       	ldi	r24, 0xFF	; 255
 24c:	c8 1a       	sub	r12, r24
 24e:	d8 0a       	sbc	r13, r24
	static uint8_t isKeyPressed = 0;
	uint8_t rowN = -1;          // Row Number
	uint8_t colN = -1;          // Column Number
	char pKey = ' ';            // Pressed Key
	
	for(uint8_t i = 0; i<3; i++)
 250:	ea 14       	cp	r14, r10
 252:	fb 04       	cpc	r15, r11
 254:	61 f6       	brne	.-104    	; 0x1ee <keypad_scan+0x48>
 256:	0b c0       	rjmp	.+22     	; 0x26e <keypad_scan+0xc8>
	
	// To return the scanned key, wait for user to remove his finger from the button.
	// Prevents sending the same input, several times.
	if(pKey != ' ' && isKeyPressed == 0)
	{
		isKeyPressed = 1;
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	80 93 6e 02 	sts	0x026E, r24	; 0x80026e <__data_end>
		return pKey;
 25e:	87 2d       	mov	r24, r7
 260:	09 c0       	rjmp	.+18     	; 0x274 <keypad_scan+0xce>
			break;
	}
	
	// To return the scanned key, wait for user to remove his finger from the button.
	// Prevents sending the same input, several times.
	if(pKey != ' ' && isKeyPressed == 0)
 262:	80 91 6e 02 	lds	r24, 0x026E	; 0x80026e <__data_end>
 266:	88 23       	and	r24, r24
 268:	b9 f3       	breq	.-18     	; 0x258 <keypad_scan+0xb2>
		return pKey;
	}	
	else
	{
		pKey = ' ';
		return pKey;
 26a:	80 e2       	ldi	r24, 0x20	; 32
 26c:	03 c0       	rjmp	.+6      	; 0x274 <keypad_scan+0xce>
		isKeyPressed = 1;
		return pKey;
	}
	else if(pKey == ' ')
	{
		isKeyPressed = 0;
 26e:	10 92 6e 02 	sts	0x026E, r1	; 0x80026e <__data_end>
		return pKey;
 272:	80 e2       	ldi	r24, 0x20	; 32
	{
		pKey = ' ';
		return pKey;
	}
	
 274:	df 91       	pop	r29
 276:	cf 91       	pop	r28
 278:	1f 91       	pop	r17
 27a:	0f 91       	pop	r16
 27c:	ff 90       	pop	r15
 27e:	ef 90       	pop	r14
 280:	df 90       	pop	r13
 282:	cf 90       	pop	r12
 284:	bf 90       	pop	r11
 286:	af 90       	pop	r10
 288:	9f 90       	pop	r9
 28a:	8f 90       	pop	r8
 28c:	7f 90       	pop	r7
 28e:	08 95       	ret

00000290 <toggle_e>:
 290:	29 9a       	sbi	0x05, 1	; 5
 292:	85 e0       	ldi	r24, 0x05	; 5
 294:	8a 95       	dec	r24
 296:	f1 f7       	brne	.-4      	; 0x294 <toggle_e+0x4>
 298:	00 00       	nop
 29a:	29 98       	cbi	0x05, 1	; 5
 29c:	08 95       	ret

0000029e <lcd_write>:
 29e:	cf 93       	push	r28
 2a0:	c8 2f       	mov	r28, r24
 2a2:	66 23       	and	r22, r22
 2a4:	11 f0       	breq	.+4      	; 0x2aa <lcd_write+0xc>
 2a6:	28 9a       	sbi	0x05, 0	; 5
 2a8:	01 c0       	rjmp	.+2      	; 0x2ac <lcd_write+0xe>
 2aa:	28 98       	cbi	0x05, 0	; 5
 2ac:	54 9a       	sbi	0x0a, 4	; 10
 2ae:	55 9a       	sbi	0x0a, 5	; 10
 2b0:	56 9a       	sbi	0x0a, 6	; 10
 2b2:	57 9a       	sbi	0x0a, 7	; 10
 2b4:	5f 98       	cbi	0x0b, 7	; 11
 2b6:	5e 98       	cbi	0x0b, 6	; 11
 2b8:	5d 98       	cbi	0x0b, 5	; 11
 2ba:	5c 98       	cbi	0x0b, 4	; 11
 2bc:	cc 23       	and	r28, r28
 2be:	0c f4       	brge	.+2      	; 0x2c2 <lcd_write+0x24>
 2c0:	5f 9a       	sbi	0x0b, 7	; 11
 2c2:	c6 fd       	sbrc	r28, 6
 2c4:	5e 9a       	sbi	0x0b, 6	; 11
 2c6:	c5 fd       	sbrc	r28, 5
 2c8:	5d 9a       	sbi	0x0b, 5	; 11
 2ca:	c4 fd       	sbrc	r28, 4
 2cc:	5c 9a       	sbi	0x0b, 4	; 11
 2ce:	0e 94 48 01 	call	0x290	; 0x290 <toggle_e>
 2d2:	5f 98       	cbi	0x0b, 7	; 11
 2d4:	5e 98       	cbi	0x0b, 6	; 11
 2d6:	5d 98       	cbi	0x0b, 5	; 11
 2d8:	5c 98       	cbi	0x0b, 4	; 11
 2da:	c3 fd       	sbrc	r28, 3
 2dc:	5f 9a       	sbi	0x0b, 7	; 11
 2de:	c2 fd       	sbrc	r28, 2
 2e0:	5e 9a       	sbi	0x0b, 6	; 11
 2e2:	c1 fd       	sbrc	r28, 1
 2e4:	5d 9a       	sbi	0x0b, 5	; 11
 2e6:	c0 fd       	sbrc	r28, 0
 2e8:	5c 9a       	sbi	0x0b, 4	; 11
 2ea:	0e 94 48 01 	call	0x290	; 0x290 <toggle_e>
 2ee:	5c 9a       	sbi	0x0b, 4	; 11
 2f0:	5d 9a       	sbi	0x0b, 5	; 11
 2f2:	5e 9a       	sbi	0x0b, 6	; 11
 2f4:	5f 9a       	sbi	0x0b, 7	; 11
 2f6:	87 eb       	ldi	r24, 0xB7	; 183
 2f8:	9b e0       	ldi	r25, 0x0B	; 11
 2fa:	01 97       	sbiw	r24, 0x01	; 1
 2fc:	f1 f7       	brne	.-4      	; 0x2fa <lcd_write+0x5c>
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <lcd_write+0x62>
 300:	00 00       	nop
 302:	cf 91       	pop	r28
 304:	08 95       	ret

00000306 <lcd_command>:
 306:	60 e0       	ldi	r22, 0x00	; 0
 308:	0e 94 4f 01 	call	0x29e	; 0x29e <lcd_write>
 30c:	08 95       	ret

0000030e <lcd_data>:
 30e:	61 e0       	ldi	r22, 0x01	; 1
 310:	0e 94 4f 01 	call	0x29e	; 0x29e <lcd_write>
 314:	08 95       	ret

00000316 <lcd_gotoxy>:
 316:	61 11       	cpse	r22, r1
 318:	04 c0       	rjmp	.+8      	; 0x322 <lcd_gotoxy+0xc>
 31a:	80 58       	subi	r24, 0x80	; 128
 31c:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 320:	08 95       	ret
 322:	61 30       	cpi	r22, 0x01	; 1
 324:	21 f4       	brne	.+8      	; 0x32e <lcd_gotoxy+0x18>
 326:	80 54       	subi	r24, 0x40	; 64
 328:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 32c:	08 95       	ret
 32e:	62 30       	cpi	r22, 0x02	; 2
 330:	21 f4       	brne	.+8      	; 0x33a <lcd_gotoxy+0x24>
 332:	8c 56       	subi	r24, 0x6C	; 108
 334:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 338:	08 95       	ret
 33a:	8c 52       	subi	r24, 0x2C	; 44
 33c:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 340:	08 95       	ret

00000342 <lcd_clrscr>:
 342:	81 e0       	ldi	r24, 0x01	; 1
 344:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 348:	08 95       	ret

0000034a <lcd_putc>:
 34a:	61 e0       	ldi	r22, 0x01	; 1
 34c:	0e 94 4f 01 	call	0x29e	; 0x29e <lcd_write>
 350:	08 95       	ret

00000352 <lcd_puts>:
 352:	cf 93       	push	r28
 354:	df 93       	push	r29
 356:	ec 01       	movw	r28, r24
 358:	21 96       	adiw	r28, 0x01	; 1
 35a:	fc 01       	movw	r30, r24
 35c:	80 81       	ld	r24, Z
 35e:	88 23       	and	r24, r24
 360:	29 f0       	breq	.+10     	; 0x36c <lcd_puts+0x1a>
 362:	0e 94 a5 01 	call	0x34a	; 0x34a <lcd_putc>
 366:	89 91       	ld	r24, Y+
 368:	81 11       	cpse	r24, r1
 36a:	fb cf       	rjmp	.-10     	; 0x362 <lcd_puts+0x10>
 36c:	df 91       	pop	r29
 36e:	cf 91       	pop	r28
 370:	08 95       	ret

00000372 <lcd_init>:
 372:	cf 93       	push	r28
 374:	c8 2f       	mov	r28, r24
 376:	20 9a       	sbi	0x04, 0	; 4
 378:	55 9a       	sbi	0x0a, 5	; 10
 37a:	21 9a       	sbi	0x04, 1	; 4
 37c:	54 9a       	sbi	0x0a, 4	; 10
 37e:	55 9a       	sbi	0x0a, 5	; 10
 380:	56 9a       	sbi	0x0a, 6	; 10
 382:	57 9a       	sbi	0x0a, 7	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 384:	8f ef       	ldi	r24, 0xFF	; 255
 386:	99 ef       	ldi	r25, 0xF9	; 249
 388:	01 97       	sbiw	r24, 0x01	; 1
 38a:	f1 f7       	brne	.-4      	; 0x388 <lcd_init+0x16>
 38c:	00 c0       	rjmp	.+0      	; 0x38e <lcd_init+0x1c>
 38e:	00 00       	nop
 390:	5d 9a       	sbi	0x0b, 5	; 11
 392:	5c 9a       	sbi	0x0b, 4	; 11
 394:	0e 94 48 01 	call	0x290	; 0x290 <toggle_e>
 398:	8f e1       	ldi	r24, 0x1F	; 31
 39a:	9e e4       	ldi	r25, 0x4E	; 78
 39c:	01 97       	sbiw	r24, 0x01	; 1
 39e:	f1 f7       	brne	.-4      	; 0x39c <lcd_init+0x2a>
 3a0:	00 c0       	rjmp	.+0      	; 0x3a2 <lcd_init+0x30>
 3a2:	00 00       	nop
 3a4:	0e 94 48 01 	call	0x290	; 0x290 <toggle_e>
 3a8:	8f ef       	ldi	r24, 0xFF	; 255
 3aa:	90 e0       	ldi	r25, 0x00	; 0
 3ac:	01 97       	sbiw	r24, 0x01	; 1
 3ae:	f1 f7       	brne	.-4      	; 0x3ac <lcd_init+0x3a>
 3b0:	00 c0       	rjmp	.+0      	; 0x3b2 <lcd_init+0x40>
 3b2:	00 00       	nop
 3b4:	0e 94 48 01 	call	0x290	; 0x290 <toggle_e>
 3b8:	8f ef       	ldi	r24, 0xFF	; 255
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	01 97       	sbiw	r24, 0x01	; 1
 3be:	f1 f7       	brne	.-4      	; 0x3bc <lcd_init+0x4a>
 3c0:	00 c0       	rjmp	.+0      	; 0x3c2 <lcd_init+0x50>
 3c2:	00 00       	nop
 3c4:	5c 98       	cbi	0x0b, 4	; 11
 3c6:	0e 94 48 01 	call	0x290	; 0x290 <toggle_e>
 3ca:	8f ef       	ldi	r24, 0xFF	; 255
 3cc:	90 e0       	ldi	r25, 0x00	; 0
 3ce:	01 97       	sbiw	r24, 0x01	; 1
 3d0:	f1 f7       	brne	.-4      	; 0x3ce <lcd_init+0x5c>
 3d2:	00 c0       	rjmp	.+0      	; 0x3d4 <lcd_init+0x62>
 3d4:	00 00       	nop
 3d6:	88 e2       	ldi	r24, 0x28	; 40
 3d8:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 3dc:	88 e0       	ldi	r24, 0x08	; 8
 3de:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 3e2:	0e 94 a1 01 	call	0x342	; 0x342 <lcd_clrscr>
 3e6:	86 e0       	ldi	r24, 0x06	; 6
 3e8:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 3ec:	8c 2f       	mov	r24, r28
 3ee:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 3f2:	cf 91       	pop	r28
 3f4:	08 95       	ret

000003f6 <__vector_13>:
	}
}

// Interrupt Handler for creating 5s and 3s timers
ISR(TIMER1_OVF_vect)
{
 3f6:	1f 92       	push	r1
 3f8:	0f 92       	push	r0
 3fa:	0f b6       	in	r0, 0x3f	; 63
 3fc:	0f 92       	push	r0
 3fe:	11 24       	eor	r1, r1
 400:	2f 93       	push	r18
 402:	3f 93       	push	r19
 404:	4f 93       	push	r20
 406:	5f 93       	push	r21
 408:	6f 93       	push	r22
 40a:	7f 93       	push	r23
 40c:	8f 93       	push	r24
 40e:	9f 93       	push	r25
 410:	af 93       	push	r26
 412:	bf 93       	push	r27
 414:	ef 93       	push	r30
 416:	ff 93       	push	r31
 418:	cf 93       	push	r28
 41a:	df 93       	push	r29
 41c:	00 d0       	rcall	.+0      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 41e:	cd b7       	in	r28, 0x3d	; 61
 420:	de b7       	in	r29, 0x3e	; 62
	char string1[2] = "  ";
 422:	80 e2       	ldi	r24, 0x20	; 32
 424:	90 e2       	ldi	r25, 0x20	; 32
 426:	9a 83       	std	Y+2, r25	; 0x02
 428:	89 83       	std	Y+1, r24	; 0x01
	
	// Standby status for the counter
	if(timerStage == 0)
 42a:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timerStage>
 42e:	81 11       	cpse	r24, r1
 430:	03 c0       	rjmp	.+6      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
		timerCnt = 0;	
 432:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <timerCnt>
 436:	4d c0       	rjmp	.+154    	; 0x4d2 <__LOCK_REGION_LENGTH__+0xd2>
	// 5s Count
	else if(timerStage == 1)
 438:	81 30       	cpi	r24, 0x01	; 1
 43a:	29 f5       	brne	.+74     	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
	{
		timerCnt++;
 43c:	80 91 75 02 	lds	r24, 0x0275	; 0x800275 <timerCnt>
 440:	8f 5f       	subi	r24, 0xFF	; 255
		if(timerCnt >= 6)
 442:	86 30       	cpi	r24, 0x06	; 6
 444:	18 f4       	brcc	.+6      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
	if(timerStage == 0)
		timerCnt = 0;	
	// 5s Count
	else if(timerStage == 1)
	{
		timerCnt++;
 446:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <timerCnt>
 44a:	04 c0       	rjmp	.+8      	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
		if(timerCnt >= 6)
		{
			timerCnt = 0;
 44c:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <timerCnt>
			timerStage = 0;
 450:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <timerStage>
		}
		
		// Configure LCD
		lcd_gotoxy(2,0);
 454:	60 e0       	ldi	r22, 0x00	; 0
 456:	82 e0       	ldi	r24, 0x02	; 2
 458:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
		lcd_puts("Remaining time: ");
 45c:	89 e2       	ldi	r24, 0x29	; 41
 45e:	91 e0       	ldi	r25, 0x01	; 1
 460:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 464:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <timerCnt>
 468:	4a e0       	ldi	r20, 0x0A	; 10
 46a:	be 01       	movw	r22, r28
 46c:	6f 5f       	subi	r22, 0xFF	; 255
 46e:	7f 4f       	sbci	r23, 0xFF	; 255
 470:	26 e0       	ldi	r18, 0x06	; 6
 472:	30 e0       	ldi	r19, 0x00	; 0
 474:	f9 01       	movw	r30, r18
 476:	e9 1b       	sub	r30, r25
 478:	f1 09       	sbc	r31, r1
 47a:	cf 01       	movw	r24, r30
 47c:	0e 94 b4 06 	call	0xd68	; 0xd68 <__itoa_ncheck>
		lcd_puts(itoa((6-timerCnt), string1, 10));
 480:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
 484:	26 c0       	rjmp	.+76     	; 0x4d2 <__LOCK_REGION_LENGTH__+0xd2>
	}
	// 3s Count
	else if(timerStage == 2)
 486:	82 30       	cpi	r24, 0x02	; 2
 488:	21 f5       	brne	.+72     	; 0x4d2 <__LOCK_REGION_LENGTH__+0xd2>
	{
		timerCnt++;
 48a:	80 91 75 02 	lds	r24, 0x0275	; 0x800275 <timerCnt>
 48e:	8f 5f       	subi	r24, 0xFF	; 255
		if(timerCnt >= 4)
 490:	84 30       	cpi	r24, 0x04	; 4
 492:	18 f4       	brcc	.+6      	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
		lcd_puts(itoa((6-timerCnt), string1, 10));
	}
	// 3s Count
	else if(timerStage == 2)
	{
		timerCnt++;
 494:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <timerCnt>
 498:	04 c0       	rjmp	.+8      	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
		if(timerCnt >= 4)
		{
			timerCnt = 0;
 49a:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <timerCnt>
			timerStage = 0;
 49e:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <timerStage>
		}
		
		// Configure LCD
		lcd_gotoxy(2,0);
 4a2:	60 e0       	ldi	r22, 0x00	; 0
 4a4:	82 e0       	ldi	r24, 0x02	; 2
 4a6:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
		lcd_puts("Remaining time: ");
 4aa:	89 e2       	ldi	r24, 0x29	; 41
 4ac:	91 e0       	ldi	r25, 0x01	; 1
 4ae:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
 4b2:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <timerCnt>
 4b6:	4a e0       	ldi	r20, 0x0A	; 10
 4b8:	be 01       	movw	r22, r28
 4ba:	6f 5f       	subi	r22, 0xFF	; 255
 4bc:	7f 4f       	sbci	r23, 0xFF	; 255
 4be:	24 e0       	ldi	r18, 0x04	; 4
 4c0:	30 e0       	ldi	r19, 0x00	; 0
 4c2:	f9 01       	movw	r30, r18
 4c4:	e9 1b       	sub	r30, r25
 4c6:	f1 09       	sbc	r31, r1
 4c8:	cf 01       	movw	r24, r30
 4ca:	0e 94 b4 06 	call	0xd68	; 0xd68 <__itoa_ncheck>
		lcd_puts(itoa((4-timerCnt), string1, 10));
 4ce:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	}
}
 4d2:	0f 90       	pop	r0
 4d4:	0f 90       	pop	r0
 4d6:	df 91       	pop	r29
 4d8:	cf 91       	pop	r28
 4da:	ff 91       	pop	r31
 4dc:	ef 91       	pop	r30
 4de:	bf 91       	pop	r27
 4e0:	af 91       	pop	r26
 4e2:	9f 91       	pop	r25
 4e4:	8f 91       	pop	r24
 4e6:	7f 91       	pop	r23
 4e8:	6f 91       	pop	r22
 4ea:	5f 91       	pop	r21
 4ec:	4f 91       	pop	r20
 4ee:	3f 91       	pop	r19
 4f0:	2f 91       	pop	r18
 4f2:	0f 90       	pop	r0
 4f4:	0f be       	out	0x3f, r0	; 63
 4f6:	0f 90       	pop	r0
 4f8:	1f 90       	pop	r1
 4fa:	18 95       	reti

000004fc <__vector_9>:

// Interrupt Handler for creating PWM signals for buzzers
ISR(TIMER2_OVF_vect)
{
 4fc:	1f 92       	push	r1
 4fe:	0f 92       	push	r0
 500:	0f b6       	in	r0, 0x3f	; 63
 502:	0f 92       	push	r0
 504:	11 24       	eor	r1, r1
 506:	2f 93       	push	r18
 508:	3f 93       	push	r19
 50a:	4f 93       	push	r20
 50c:	5f 93       	push	r21
 50e:	6f 93       	push	r22
 510:	7f 93       	push	r23
 512:	8f 93       	push	r24
 514:	9f 93       	push	r25
 516:	af 93       	push	r26
 518:	bf 93       	push	r27
 51a:	ef 93       	push	r30
 51c:	ff 93       	push	r31
	volatile static uint8_t buzzerCnt = 0;
	
	// Buzzer at standby
	if(buzzerStage == 0)
 51e:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <buzzerStage>
 522:	81 11       	cpse	r24, r1
 524:	0b c0       	rjmp	.+22     	; 0x53c <__vector_9+0x40>
	{
		GPIO_write_low(&PORTB, Buzzer);
 526:	65 e0       	ldi	r22, 0x05	; 5
 528:	85 e2       	ldi	r24, 0x25	; 37
 52a:	90 e0       	ldi	r25, 0x00	; 0
 52c:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
		GPIO_write_low(&PORTB, doorBell);
 530:	64 e0       	ldi	r22, 0x04	; 4
 532:	85 e2       	ldi	r24, 0x25	; 37
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
 53a:	ea c0       	rjmp	.+468    	; 0x710 <__vector_9+0x214>
	}
	
	// Button press buzzer
	else if(buzzerStage == 1)
 53c:	81 30       	cpi	r24, 0x01	; 1
 53e:	a1 f4       	brne	.+40     	; 0x568 <__vector_9+0x6c>
	{
		GPIO_write_high(&PORTB, Buzzer);
 540:	65 e0       	ldi	r22, 0x05	; 5
 542:	85 e2       	ldi	r24, 0x25	; 37
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
		
		buzzerCnt++;
 54a:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 54e:	8f 5f       	subi	r24, 0xFF	; 255
 550:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <buzzerCnt.2024>
		if(buzzerCnt == 10)
 554:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 558:	8a 30       	cpi	r24, 0x0A	; 10
 55a:	09 f0       	breq	.+2      	; 0x55e <__vector_9+0x62>
 55c:	d9 c0       	rjmp	.+434    	; 0x710 <__vector_9+0x214>
		{
			buzzerCnt = 0;
 55e:	10 92 6f 02 	sts	0x026F, r1	; 0x80026f <buzzerCnt.2024>
			buzzerStage = 0;
 562:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <buzzerStage>
 566:	d4 c0       	rjmp	.+424    	; 0x710 <__vector_9+0x214>
		}
	}
	// Correct Pin Buzzer
	else if(buzzerStage == 2)
 568:	82 30       	cpi	r24, 0x02	; 2
 56a:	a1 f4       	brne	.+40     	; 0x594 <__vector_9+0x98>
	{
		GPIO_write_high(&PORTB, Buzzer);
 56c:	65 e0       	ldi	r22, 0x05	; 5
 56e:	85 e2       	ldi	r24, 0x25	; 37
 570:	90 e0       	ldi	r25, 0x00	; 0
 572:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
		
		buzzerCnt++;
 576:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 57a:	8f 5f       	subi	r24, 0xFF	; 255
 57c:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <buzzerCnt.2024>
		if(buzzerCnt == 50)
 580:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 584:	82 33       	cpi	r24, 0x32	; 50
 586:	09 f0       	breq	.+2      	; 0x58a <__vector_9+0x8e>
 588:	c3 c0       	rjmp	.+390    	; 0x710 <__vector_9+0x214>
		{
			buzzerCnt = 0;
 58a:	10 92 6f 02 	sts	0x026F, r1	; 0x80026f <buzzerCnt.2024>
			buzzerStage = 0;
 58e:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <buzzerStage>
 592:	be c0       	rjmp	.+380    	; 0x710 <__vector_9+0x214>
		}
	}
	// Wrong Pin Buzzer
	else if(buzzerStage == 3)
 594:	83 30       	cpi	r24, 0x03	; 3
 596:	49 f5       	brne	.+82     	; 0x5ea <__vector_9+0xee>
	{
		GPIO_write_high(&PORTB, Buzzer);
 598:	65 e0       	ldi	r22, 0x05	; 5
 59a:	85 e2       	ldi	r24, 0x25	; 37
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
		
		buzzerCnt++;
 5a2:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 5a6:	8f 5f       	subi	r24, 0xFF	; 255
 5a8:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <buzzerCnt.2024>
		if((buzzerCnt % 10) == 0)
 5ac:	20 91 6f 02 	lds	r18, 0x026F	; 0x80026f <buzzerCnt.2024>
 5b0:	8d ec       	ldi	r24, 0xCD	; 205
 5b2:	28 9f       	mul	r18, r24
 5b4:	81 2d       	mov	r24, r1
 5b6:	11 24       	eor	r1, r1
 5b8:	86 95       	lsr	r24
 5ba:	86 95       	lsr	r24
 5bc:	86 95       	lsr	r24
 5be:	88 0f       	add	r24, r24
 5c0:	98 2f       	mov	r25, r24
 5c2:	99 0f       	add	r25, r25
 5c4:	99 0f       	add	r25, r25
 5c6:	89 0f       	add	r24, r25
 5c8:	28 13       	cpse	r18, r24
 5ca:	05 c0       	rjmp	.+10     	; 0x5d6 <__vector_9+0xda>
		{
			GPIO_toggle(&PORTB, Buzzer);
 5cc:	65 e0       	ldi	r22, 0x05	; 5
 5ce:	85 e2       	ldi	r24, 0x25	; 37
 5d0:	90 e0       	ldi	r25, 0x00	; 0
 5d2:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		}
		if(buzzerCnt == 50)
 5d6:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 5da:	82 33       	cpi	r24, 0x32	; 50
 5dc:	09 f0       	breq	.+2      	; 0x5e0 <__vector_9+0xe4>
 5de:	98 c0       	rjmp	.+304    	; 0x710 <__vector_9+0x214>
		{
			buzzerCnt = 0;
 5e0:	10 92 6f 02 	sts	0x026F, r1	; 0x80026f <buzzerCnt.2024>
			buzzerStage = 0;
 5e4:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <buzzerStage>
 5e8:	93 c0       	rjmp	.+294    	; 0x710 <__vector_9+0x214>
		}
	}
	// Door Bell Buzzer
	else if(buzzerStage == 4)
 5ea:	84 30       	cpi	r24, 0x04	; 4
 5ec:	09 f0       	breq	.+2      	; 0x5f0 <__vector_9+0xf4>
 5ee:	90 c0       	rjmp	.+288    	; 0x710 <__vector_9+0x214>
	{
		GPIO_write_high(&PORTB, doorBell);
 5f0:	64 e0       	ldi	r22, 0x04	; 4
 5f2:	85 e2       	ldi	r24, 0x25	; 37
 5f4:	90 e0       	ldi	r25, 0x00	; 0
 5f6:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
		
		buzzerCnt++;
 5fa:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 5fe:	8f 5f       	subi	r24, 0xFF	; 255
 600:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <buzzerCnt.2024>
		if(buzzerCnt == 10)
 604:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 608:	8a 30       	cpi	r24, 0x0A	; 10
 60a:	29 f4       	brne	.+10     	; 0x616 <__vector_9+0x11a>
			GPIO_toggle(&PORTB, doorBell);
 60c:	64 e0       	ldi	r22, 0x04	; 4
 60e:	85 e2       	ldi	r24, 0x25	; 37
 610:	90 e0       	ldi	r25, 0x00	; 0
 612:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 15)
 616:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 61a:	8f 30       	cpi	r24, 0x0F	; 15
 61c:	29 f4       	brne	.+10     	; 0x628 <__vector_9+0x12c>
			GPIO_toggle(&PORTB, doorBell);
 61e:	64 e0       	ldi	r22, 0x04	; 4
 620:	85 e2       	ldi	r24, 0x25	; 37
 622:	90 e0       	ldi	r25, 0x00	; 0
 624:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 20)
 628:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 62c:	84 31       	cpi	r24, 0x14	; 20
 62e:	29 f4       	brne	.+10     	; 0x63a <__vector_9+0x13e>
			GPIO_toggle(&PORTB, doorBell);
 630:	64 e0       	ldi	r22, 0x04	; 4
 632:	85 e2       	ldi	r24, 0x25	; 37
 634:	90 e0       	ldi	r25, 0x00	; 0
 636:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 30)
 63a:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 63e:	8e 31       	cpi	r24, 0x1E	; 30
 640:	29 f4       	brne	.+10     	; 0x64c <__vector_9+0x150>
			GPIO_toggle(&PORTB, doorBell);
 642:	64 e0       	ldi	r22, 0x04	; 4
 644:	85 e2       	ldi	r24, 0x25	; 37
 646:	90 e0       	ldi	r25, 0x00	; 0
 648:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 35)
 64c:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 650:	83 32       	cpi	r24, 0x23	; 35
 652:	29 f4       	brne	.+10     	; 0x65e <__vector_9+0x162>
			GPIO_toggle(&PORTB, doorBell);
 654:	64 e0       	ldi	r22, 0x04	; 4
 656:	85 e2       	ldi	r24, 0x25	; 37
 658:	90 e0       	ldi	r25, 0x00	; 0
 65a:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 40)
 65e:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 662:	88 32       	cpi	r24, 0x28	; 40
 664:	29 f4       	brne	.+10     	; 0x670 <__vector_9+0x174>
			GPIO_toggle(&PORTB, doorBell);
 666:	64 e0       	ldi	r22, 0x04	; 4
 668:	85 e2       	ldi	r24, 0x25	; 37
 66a:	90 e0       	ldi	r25, 0x00	; 0
 66c:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 50)
 670:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 674:	82 33       	cpi	r24, 0x32	; 50
 676:	29 f4       	brne	.+10     	; 0x682 <__vector_9+0x186>
			GPIO_toggle(&PORTB, doorBell);
 678:	64 e0       	ldi	r22, 0x04	; 4
 67a:	85 e2       	ldi	r24, 0x25	; 37
 67c:	90 e0       	ldi	r25, 0x00	; 0
 67e:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 60)
 682:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 686:	8c 33       	cpi	r24, 0x3C	; 60
 688:	29 f4       	brne	.+10     	; 0x694 <__vector_9+0x198>
			GPIO_toggle(&PORTB, doorBell);
 68a:	64 e0       	ldi	r22, 0x04	; 4
 68c:	85 e2       	ldi	r24, 0x25	; 37
 68e:	90 e0       	ldi	r25, 0x00	; 0
 690:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 65)
 694:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 698:	81 34       	cpi	r24, 0x41	; 65
 69a:	29 f4       	brne	.+10     	; 0x6a6 <__vector_9+0x1aa>
			GPIO_toggle(&PORTB, doorBell);
 69c:	64 e0       	ldi	r22, 0x04	; 4
 69e:	85 e2       	ldi	r24, 0x25	; 37
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 70)
 6a6:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 6aa:	86 34       	cpi	r24, 0x46	; 70
 6ac:	29 f4       	brne	.+10     	; 0x6b8 <__vector_9+0x1bc>
			GPIO_toggle(&PORTB, doorBell);
 6ae:	64 e0       	ldi	r22, 0x04	; 4
 6b0:	85 e2       	ldi	r24, 0x25	; 37
 6b2:	90 e0       	ldi	r25, 0x00	; 0
 6b4:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 80)
 6b8:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 6bc:	80 35       	cpi	r24, 0x50	; 80
 6be:	29 f4       	brne	.+10     	; 0x6ca <__vector_9+0x1ce>
			GPIO_toggle(&PORTB, doorBell);
 6c0:	64 e0       	ldi	r22, 0x04	; 4
 6c2:	85 e2       	ldi	r24, 0x25	; 37
 6c4:	90 e0       	ldi	r25, 0x00	; 0
 6c6:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 85)
 6ca:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 6ce:	85 35       	cpi	r24, 0x55	; 85
 6d0:	29 f4       	brne	.+10     	; 0x6dc <__vector_9+0x1e0>
			GPIO_toggle(&PORTB, doorBell);
 6d2:	64 e0       	ldi	r22, 0x04	; 4
 6d4:	85 e2       	ldi	r24, 0x25	; 37
 6d6:	90 e0       	ldi	r25, 0x00	; 0
 6d8:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 90)
 6dc:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 6e0:	8a 35       	cpi	r24, 0x5A	; 90
 6e2:	29 f4       	brne	.+10     	; 0x6ee <__vector_9+0x1f2>
			GPIO_toggle(&PORTB, doorBell);
 6e4:	64 e0       	ldi	r22, 0x04	; 4
 6e6:	85 e2       	ldi	r24, 0x25	; 37
 6e8:	90 e0       	ldi	r25, 0x00	; 0
 6ea:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
		if(buzzerCnt == 100)
 6ee:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 6f2:	84 36       	cpi	r24, 0x64	; 100
 6f4:	29 f4       	brne	.+10     	; 0x700 <__vector_9+0x204>
			GPIO_toggle(&PORTB, doorBell);
 6f6:	64 e0       	ldi	r22, 0x04	; 4
 6f8:	85 e2       	ldi	r24, 0x25	; 37
 6fa:	90 e0       	ldi	r25, 0x00	; 0
 6fc:	0e 94 8a 00 	call	0x114	; 0x114 <GPIO_toggle>
			
		if(buzzerCnt == 100)
 700:	80 91 6f 02 	lds	r24, 0x026F	; 0x80026f <buzzerCnt.2024>
 704:	84 36       	cpi	r24, 0x64	; 100
 706:	21 f4       	brne	.+8      	; 0x710 <__vector_9+0x214>
		{
			buzzerCnt = 0;
 708:	10 92 6f 02 	sts	0x026F, r1	; 0x80026f <buzzerCnt.2024>
			buzzerStage = 0;
 70c:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <buzzerStage>
		}
	}
}
 710:	ff 91       	pop	r31
 712:	ef 91       	pop	r30
 714:	bf 91       	pop	r27
 716:	af 91       	pop	r26
 718:	9f 91       	pop	r25
 71a:	8f 91       	pop	r24
 71c:	7f 91       	pop	r23
 71e:	6f 91       	pop	r22
 720:	5f 91       	pop	r21
 722:	4f 91       	pop	r20
 724:	3f 91       	pop	r19
 726:	2f 91       	pop	r18
 728:	0f 90       	pop	r0
 72a:	0f be       	out	0x3f, r0	; 63
 72c:	0f 90       	pop	r0
 72e:	1f 90       	pop	r1
 730:	18 95       	reti

00000732 <standby>:
/* Function definitions ----------------------------------------------*/
void standby()
{
	// Reset input ID
	inID = -1;
 732:	8f ef       	ldi	r24, 0xFF	; 255
 734:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <inID>
	
	// Reset typed pin
	inPin[0] = ' ';
 738:	e5 e2       	ldi	r30, 0x25	; 37
 73a:	f1 e0       	ldi	r31, 0x01	; 1
 73c:	80 e2       	ldi	r24, 0x20	; 32
 73e:	80 83       	st	Z, r24
	inPin[1] = ' ';
 740:	81 83       	std	Z+1, r24	; 0x01
	inPin[2] = ' ';
 742:	82 83       	std	Z+2, r24	; 0x02
	inPin[3] = ' ';
 744:	83 83       	std	Z+3, r24	; 0x03
	
	// Reset Leds
	GPIO_write_low(&PORTB, greenLed);
 746:	67 e0       	ldi	r22, 0x07	; 7
 748:	85 e2       	ldi	r24, 0x25	; 37
 74a:	90 e0       	ldi	r25, 0x00	; 0
 74c:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	GPIO_write_low(&PORTB, redLed);
 750:	66 e0       	ldi	r22, 0x06	; 6
 752:	85 e2       	ldi	r24, 0x25	; 37
 754:	90 e0       	ldi	r25, 0x00	; 0
 756:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	// Lock the door
	GPIO_write_low(&PORTB, Relay);
 75a:	63 e0       	ldi	r22, 0x03	; 3
 75c:	85 e2       	ldi	r24, 0x25	; 37
 75e:	90 e0       	ldi	r25, 0x00	; 0
 760:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	// Clear the lcd screen
	lcd_clrscr();
 764:	0e 94 a1 01 	call	0x342	; 0x342 <lcd_clrscr>
	// Print to lcd screen
	lcd_gotoxy(2,0);
 768:	60 e0       	ldi	r22, 0x00	; 0
 76a:	82 e0       	ldi	r24, 0x02	; 2
 76c:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("Dumbledoor wishes");
 770:	8a e3       	ldi	r24, 0x3A	; 58
 772:	91 e0       	ldi	r25, 0x01	; 1
 774:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_gotoxy(4,1);
 778:	61 e0       	ldi	r22, 0x01	; 1
 77a:	84 e0       	ldi	r24, 0x04	; 4
 77c:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("Magical Days!");
 780:	8c e4       	ldi	r24, 0x4C	; 76
 782:	91 e0       	ldi	r25, 0x01	; 1
 784:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_gotoxy(1,2);
 788:	62 e0       	ldi	r22, 0x02	; 2
 78a:	81 e0       	ldi	r24, 0x01	; 1
 78c:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("* --> Enter the pin");
 790:	8a e5       	ldi	r24, 0x5A	; 90
 792:	91 e0       	ldi	r25, 0x01	; 1
 794:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_gotoxy(1,3);
 798:	63 e0       	ldi	r22, 0x03	; 3
 79a:	81 e0       	ldi	r24, 0x01	; 1
 79c:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("# --> Door Bell");
 7a0:	8e e6       	ldi	r24, 0x6E	; 110
 7a2:	91 e0       	ldi	r25, 0x01	; 1
 7a4:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
 7a8:	08 95       	ret

000007aa <main>:
};

int main(void)
{
	// Initialize the LCD Display
	lcd_init(LCD_DISP_ON);
 7aa:	8c e0       	ldi	r24, 0x0C	; 12
 7ac:	0e 94 b9 01 	call	0x372	; 0x372 <lcd_init>
	
	// Initialize the Key Pad
	keypad_init();
 7b0:	0e 94 a0 00 	call	0x140	; 0x140 <keypad_init>
	
	/*Defining and Printing a custom characters*/
	// Set pointer to beginning of CGRAM memory
	lcd_command(1 << LCD_CGRAM);
 7b4:	80 e4       	ldi	r24, 0x40	; 64
 7b6:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
 7ba:	c4 e1       	ldi	r28, 0x14	; 20
 7bc:	d1 e0       	ldi	r29, 0x01	; 1
 7be:	04 e2       	ldi	r16, 0x24	; 36
 7c0:	11 e0       	ldi	r17, 0x01	; 1
	for (uint8_t i = 0; i < 16; i++)
	{
		// Store all new chars to memory line by line
		lcd_data(customChar[i]);
 7c2:	89 91       	ld	r24, Y+
 7c4:	0e 94 87 01 	call	0x30e	; 0x30e <lcd_data>
	keypad_init();
	
	/*Defining and Printing a custom characters*/
	// Set pointer to beginning of CGRAM memory
	lcd_command(1 << LCD_CGRAM);
	for (uint8_t i = 0; i < 16; i++)
 7c8:	c0 17       	cp	r28, r16
 7ca:	d1 07       	cpc	r29, r17
 7cc:	d1 f7       	brne	.-12     	; 0x7c2 <main+0x18>
	{
		// Store all new chars to memory line by line
		lcd_data(customChar[i]);
	}
	// Set DDRAM address
	lcd_command(1 << LCD_DDRAM);
 7ce:	80 e8       	ldi	r24, 0x80	; 128
 7d0:	0e 94 83 01 	call	0x306	; 0x306 <lcd_command>
	
	// Configure the Leds as output and set low
	GPIO_config_output(&DDRB, greenLed);
 7d4:	67 e0       	ldi	r22, 0x07	; 7
 7d6:	84 e2       	ldi	r24, 0x24	; 36
 7d8:	90 e0       	ldi	r25, 0x00	; 0
 7da:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_config_output(&DDRB, redLed);
 7de:	66 e0       	ldi	r22, 0x06	; 6
 7e0:	84 e2       	ldi	r24, 0x24	; 36
 7e2:	90 e0       	ldi	r25, 0x00	; 0
 7e4:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_write_low(&PORTB, greenLed);
 7e8:	67 e0       	ldi	r22, 0x07	; 7
 7ea:	85 e2       	ldi	r24, 0x25	; 37
 7ec:	90 e0       	ldi	r25, 0x00	; 0
 7ee:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	GPIO_write_low(&PORTB, redLed);	
 7f2:	66 e0       	ldi	r22, 0x06	; 6
 7f4:	85 e2       	ldi	r24, 0x25	; 37
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	// Configure the buzzer as output and set low
	GPIO_config_output(&DDRB, Buzzer);
 7fc:	65 e0       	ldi	r22, 0x05	; 5
 7fe:	84 e2       	ldi	r24, 0x24	; 36
 800:	90 e0       	ldi	r25, 0x00	; 0
 802:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_write_low(&PORTB, Buzzer);
 806:	65 e0       	ldi	r22, 0x05	; 5
 808:	85 e2       	ldi	r24, 0x25	; 37
 80a:	90 e0       	ldi	r25, 0x00	; 0
 80c:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	// Configure the doorbell as output and set low
	GPIO_config_output(&DDRB, doorBell);
 810:	64 e0       	ldi	r22, 0x04	; 4
 812:	84 e2       	ldi	r24, 0x24	; 36
 814:	90 e0       	ldi	r25, 0x00	; 0
 816:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_write_low(&PORTB, doorBell);
 81a:	64 e0       	ldi	r22, 0x04	; 4
 81c:	85 e2       	ldi	r24, 0x25	; 37
 81e:	90 e0       	ldi	r25, 0x00	; 0
 820:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	// Configure Relay as output and set low
	GPIO_config_output(&DDRB, Relay);
 824:	63 e0       	ldi	r22, 0x03	; 3
 826:	84 e2       	ldi	r24, 0x24	; 36
 828:	90 e0       	ldi	r25, 0x00	; 0
 82a:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_config_output>
	GPIO_write_low(&PORTB, Relay);	
 82e:	63 e0       	ldi	r22, 0x03	; 3
 830:	85 e2       	ldi	r24, 0x25	; 37
 832:	90 e0       	ldi	r25, 0x00	; 0
 834:	0e 94 71 00 	call	0xe2	; 0xe2 <GPIO_write_low>
	
	// Set the program to standby state
	standby();
 838:	0e 94 99 03 	call	0x732	; 0x732 <standby>
	
    	// Configure Timer/Counter0 for scanning the key pad
    	// Enable interrupt and set the overflow prescaler to 4ms
   	 TIM0_overflow_4ms();
 83c:	85 b5       	in	r24, 0x25	; 37
 83e:	8d 7f       	andi	r24, 0xFD	; 253
 840:	85 bd       	out	0x25, r24	; 37
 842:	85 b5       	in	r24, 0x25	; 37
 844:	84 60       	ori	r24, 0x04	; 4
 846:	85 bd       	out	0x25, r24	; 37
    	TIM0_overflow_interrupt_enable();
 848:	ee e6       	ldi	r30, 0x6E	; 110
 84a:	f0 e0       	ldi	r31, 0x00	; 0
 84c:	80 81       	ld	r24, Z
 84e:	81 60       	ori	r24, 0x01	; 1
 850:	80 83       	st	Z, r24
	
	// Configure Timer/Counter1 for counting timers
	// Enable interrupt and set the overflow prescaler to 1s
	TIM1_overflow_1s();
 852:	e1 e8       	ldi	r30, 0x81	; 129
 854:	f0 e0       	ldi	r31, 0x00	; 0
 856:	80 81       	ld	r24, Z
 858:	8c 7f       	andi	r24, 0xFC	; 252
 85a:	80 83       	st	Z, r24
 85c:	80 81       	ld	r24, Z
 85e:	84 60       	ori	r24, 0x04	; 4
 860:	80 83       	st	Z, r24
	TIM1_overflow_interrupt_enable();
 862:	ef e6       	ldi	r30, 0x6F	; 111
 864:	f0 e0       	ldi	r31, 0x00	; 0
 866:	80 81       	ld	r24, Z
 868:	81 60       	ori	r24, 0x01	; 1
 86a:	80 83       	st	Z, r24
	
	// Configure Timer/Counter2 to control and send PWM signals to buzzers
	// Enable interrupt and set the overflow prescaler to 16ms
	TIM2_overflow_16ms();
 86c:	e1 eb       	ldi	r30, 0xB1	; 177
 86e:	f0 e0       	ldi	r31, 0x00	; 0
 870:	80 81       	ld	r24, Z
 872:	87 60       	ori	r24, 0x07	; 7
 874:	80 83       	st	Z, r24
	TIM2_overflow_interrupt_enable();
 876:	e0 e7       	ldi	r30, 0x70	; 112
 878:	f0 e0       	ldi	r31, 0x00	; 0
 87a:	80 81       	ld	r24, Z
 87c:	81 60       	ori	r24, 0x01	; 1
 87e:	80 83       	st	Z, r24
	
   	// Initialize UART to asynchronous, 8N1, 9600
    	uart_init(UART_BAUD_SELECT(9600, F_CPU));
 880:	89 e0       	ldi	r24, 0x09	; 9
 882:	90 e0       	ldi	r25, 0x00	; 0
 884:	0e 94 77 06 	call	0xcee	; 0xcee <uart_init>
	
    	// Enables interrupts by setting the global interrupt mask
    	sei();
 888:	78 94       	sei
 88a:	ff cf       	rjmp	.-2      	; 0x88a <main+0xe0>

0000088c <ringDoorBell>:
}

void ringDoorBell() 
{	
	// Correct Pin Buzzer
	buzzerStage = 4;
 88c:	84 e0       	ldi	r24, 0x04	; 4
 88e:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <buzzerStage>
	
	// Clear the lcd screen
	lcd_clrscr();
 892:	0e 94 a1 01 	call	0x342	; 0x342 <lcd_clrscr>
	// Print to lcd screen
	lcd_gotoxy(2,2);
 896:	62 e0       	ldi	r22, 0x02	; 2
 898:	82 e0       	ldi	r24, 0x02	; 2
 89a:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("Door bell is");
 89e:	8e e7       	ldi	r24, 0x7E	; 126
 8a0:	91 e0       	ldi	r25, 0x01	; 1
 8a2:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_gotoxy(2,3);
 8a6:	63 e0       	ldi	r22, 0x03	; 3
 8a8:	82 e0       	ldi	r24, 0x02	; 2
 8aa:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("rang. ");
 8ae:	8b e8       	ldi	r24, 0x8B	; 139
 8b0:	91 e0       	ldi	r25, 0x01	; 1
 8b2:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_putc(1);
 8b6:	81 e0       	ldi	r24, 0x01	; 1
 8b8:	0e 94 a5 01 	call	0x34a	; 0x34a <lcd_putc>
	lcd_putc(1);
 8bc:	81 e0       	ldi	r24, 0x01	; 1
 8be:	0e 94 a5 01 	call	0x34a	; 0x34a <lcd_putc>
	
	// UART
	uart_puts("Door bell is rang.");
 8c2:	82 e9       	ldi	r24, 0x92	; 146
 8c4:	91 e0       	ldi	r25, 0x01	; 1
 8c6:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 8ca:	85 ea       	ldi	r24, 0xA5	; 165
 8cc:	91 e0       	ldi	r25, 0x01	; 1
 8ce:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
 8d2:	08 95       	ret

000008d4 <correctPin>:
}

void correctPin(uint8_t ID)
{	
 8d4:	0f 93       	push	r16
 8d6:	1f 93       	push	r17
 8d8:	cf 93       	push	r28
 8da:	df 93       	push	r29
 8dc:	00 d0       	rcall	.+0      	; 0x8de <correctPin+0xa>
 8de:	cd b7       	in	r28, 0x3d	; 61
 8e0:	de b7       	in	r29, 0x3e	; 62
 8e2:	08 2f       	mov	r16, r24
	char string2[2] = "  ";
 8e4:	80 e2       	ldi	r24, 0x20	; 32
 8e6:	90 e2       	ldi	r25, 0x20	; 32
 8e8:	9a 83       	std	Y+2, r25	; 0x02
 8ea:	89 83       	std	Y+1, r24	; 0x01
	
	// Unlock the door
	GPIO_write_high(&PORTB, Relay);	
 8ec:	63 e0       	ldi	r22, 0x03	; 3
 8ee:	85 e2       	ldi	r24, 0x25	; 37
 8f0:	90 e0       	ldi	r25, 0x00	; 0
 8f2:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>

	// Light up the green led
	GPIO_write_high(&PORTB, greenLed);
 8f6:	67 e0       	ldi	r22, 0x07	; 7
 8f8:	85 e2       	ldi	r24, 0x25	; 37
 8fa:	90 e0       	ldi	r25, 0x00	; 0
 8fc:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	
	// Correct Pin Buzzer
	buzzerStage = 2;
 900:	82 e0       	ldi	r24, 0x02	; 2
 902:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <buzzerStage>
	
	// Update Correct Attempts
	correctAttempts++;
 906:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <correctAttempts>
 90a:	8f 5f       	subi	r24, 0xFF	; 255
 90c:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <correctAttempts>
	
	// Clear the lcd screen
	lcd_clrscr();
 910:	0e 94 a1 01 	call	0x342	; 0x342 <lcd_clrscr>
	// Print to lcd screen
	lcd_gotoxy(2,1);
 914:	61 e0       	ldi	r22, 0x01	; 1
 916:	82 e0       	ldi	r24, 0x02	; 2
 918:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("Correct pin.");
 91c:	88 ea       	ldi	r24, 0xA8	; 168
 91e:	91 e0       	ldi	r25, 0x01	; 1
 920:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_gotoxy(2,2);
 924:	62 e0       	ldi	r22, 0x02	; 2
 926:	82 e0       	ldi	r24, 0x02	; 2
 928:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("Hello ");
 92c:	85 eb       	ldi	r24, 0xB5	; 181
 92e:	91 e0       	ldi	r25, 0x01	; 1
 930:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	lcd_putc(0);
 934:	80 e0       	ldi	r24, 0x00	; 0
 936:	0e 94 a5 01 	call	0x34a	; 0x34a <lcd_putc>
	lcd_putc(0);
 93a:	80 e0       	ldi	r24, 0x00	; 0
 93c:	0e 94 a5 01 	call	0x34a	; 0x34a <lcd_putc>
	lcd_gotoxy(2,3);
 940:	63 e0       	ldi	r22, 0x03	; 3
 942:	82 e0       	ldi	r24, 0x02	; 2
 944:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts(names[ID]);
 948:	8d e0       	ldi	r24, 0x0D	; 13
 94a:	08 9f       	mul	r16, r24
 94c:	80 01       	movw	r16, r0
 94e:	11 24       	eor	r1, r1
 950:	06 5d       	subi	r16, 0xD6	; 214
 952:	1d 4f       	sbci	r17, 0xFD	; 253
 954:	c8 01       	movw	r24, r16
 956:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	
	// UART
	uart_puts(names[ID]);
 95a:	c8 01       	movw	r24, r16
 95c:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts(" entered to the room!");
 960:	8c eb       	ldi	r24, 0xBC	; 188
 962:	91 e0       	ldi	r25, 0x01	; 1
 964:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");	
 968:	85 ea       	ldi	r24, 0xA5	; 165
 96a:	91 e0       	ldi	r25, 0x01	; 1
 96c:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("Total Attempts: ");
 970:	82 ed       	ldi	r24, 0xD2	; 210
 972:	91 e0       	ldi	r25, 0x01	; 1
 974:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 978:	85 ea       	ldi	r24, 0xA5	; 165
 97a:	91 e0       	ldi	r25, 0x01	; 1
 97c:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("Correct: ");
 980:	83 ee       	ldi	r24, 0xE3	; 227
 982:	91 e0       	ldi	r25, 0x01	; 1
 984:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
 988:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <correctAttempts>
 98c:	4a e0       	ldi	r20, 0x0A	; 10
 98e:	be 01       	movw	r22, r28
 990:	6f 5f       	subi	r22, 0xFF	; 255
 992:	7f 4f       	sbci	r23, 0xFF	; 255
 994:	90 e0       	ldi	r25, 0x00	; 0
 996:	0e 94 b4 06 	call	0xd68	; 0xd68 <__itoa_ncheck>
	uart_puts(itoa(correctAttempts, string2, 10));
 99a:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 99e:	85 ea       	ldi	r24, 0xA5	; 165
 9a0:	91 e0       	ldi	r25, 0x01	; 1
 9a2:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("Wrong: ");
 9a6:	8d ee       	ldi	r24, 0xED	; 237
 9a8:	91 e0       	ldi	r25, 0x01	; 1
 9aa:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
 9ae:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <wrongAttempts>
 9b2:	4a e0       	ldi	r20, 0x0A	; 10
 9b4:	be 01       	movw	r22, r28
 9b6:	6f 5f       	subi	r22, 0xFF	; 255
 9b8:	7f 4f       	sbci	r23, 0xFF	; 255
 9ba:	90 e0       	ldi	r25, 0x00	; 0
 9bc:	0e 94 b4 06 	call	0xd68	; 0xd68 <__itoa_ncheck>
	uart_puts(itoa(wrongAttempts, string2, 10));
 9c0:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 9c4:	85 ea       	ldi	r24, 0xA5	; 165
 9c6:	91 e0       	ldi	r25, 0x01	; 1
 9c8:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
}
 9cc:	0f 90       	pop	r0
 9ce:	0f 90       	pop	r0
 9d0:	df 91       	pop	r29
 9d2:	cf 91       	pop	r28
 9d4:	1f 91       	pop	r17
 9d6:	0f 91       	pop	r16
 9d8:	08 95       	ret

000009da <wrongPin>:

void wrongPin()
{	
 9da:	cf 93       	push	r28
 9dc:	df 93       	push	r29
 9de:	00 d0       	rcall	.+0      	; 0x9e0 <wrongPin+0x6>
 9e0:	cd b7       	in	r28, 0x3d	; 61
 9e2:	de b7       	in	r29, 0x3e	; 62
	char string2[2] = "  ";
 9e4:	80 e2       	ldi	r24, 0x20	; 32
 9e6:	90 e2       	ldi	r25, 0x20	; 32
 9e8:	9a 83       	std	Y+2, r25	; 0x02
 9ea:	89 83       	std	Y+1, r24	; 0x01
	
	// Light up the red led
	GPIO_write_high(&PORTB, redLed);
 9ec:	66 e0       	ldi	r22, 0x06	; 6
 9ee:	85 e2       	ldi	r24, 0x25	; 37
 9f0:	90 e0       	ldi	r25, 0x00	; 0
 9f2:	0e 94 7e 00 	call	0xfc	; 0xfc <GPIO_write_high>
	
	// Correct Pin Buzzer
	buzzerStage = 3;
 9f6:	83 e0       	ldi	r24, 0x03	; 3
 9f8:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <buzzerStage>
	
	// Update Wrong Attempts
	wrongAttempts++;
 9fc:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <wrongAttempts>
 a00:	8f 5f       	subi	r24, 0xFF	; 255
 a02:	80 93 72 02 	sts	0x0272, r24	; 0x800272 <wrongAttempts>
	
	// Clear the lcd screen
	lcd_clrscr();
 a06:	0e 94 a1 01 	call	0x342	; 0x342 <lcd_clrscr>
	// Print to lcd screen
	lcd_gotoxy(2,2);
 a0a:	62 e0       	ldi	r22, 0x02	; 2
 a0c:	82 e0       	ldi	r24, 0x02	; 2
 a0e:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
	lcd_puts("Wrong pin.");
 a12:	85 ef       	ldi	r24, 0xF5	; 245
 a14:	91 e0       	ldi	r25, 0x01	; 1
 a16:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	
	// UART
	uart_puts("Wrong attempt to enter!");
 a1a:	80 e0       	ldi	r24, 0x00	; 0
 a1c:	92 e0       	ldi	r25, 0x02	; 2
 a1e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 a22:	85 ea       	ldi	r24, 0xA5	; 165
 a24:	91 e0       	ldi	r25, 0x01	; 1
 a26:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("Total Attempts: ");
 a2a:	82 ed       	ldi	r24, 0xD2	; 210
 a2c:	91 e0       	ldi	r25, 0x01	; 1
 a2e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 a32:	85 ea       	ldi	r24, 0xA5	; 165
 a34:	91 e0       	ldi	r25, 0x01	; 1
 a36:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("Correct: ");
 a3a:	83 ee       	ldi	r24, 0xE3	; 227
 a3c:	91 e0       	ldi	r25, 0x01	; 1
 a3e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
 a42:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <correctAttempts>
 a46:	4a e0       	ldi	r20, 0x0A	; 10
 a48:	be 01       	movw	r22, r28
 a4a:	6f 5f       	subi	r22, 0xFF	; 255
 a4c:	7f 4f       	sbci	r23, 0xFF	; 255
 a4e:	90 e0       	ldi	r25, 0x00	; 0
 a50:	0e 94 b4 06 	call	0xd68	; 0xd68 <__itoa_ncheck>
	uart_puts(itoa(correctAttempts, string2, 10));
 a54:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 a58:	85 ea       	ldi	r24, 0xA5	; 165
 a5a:	91 e0       	ldi	r25, 0x01	; 1
 a5c:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("Wrong: ");
 a60:	8d ee       	ldi	r24, 0xED	; 237
 a62:	91 e0       	ldi	r25, 0x01	; 1
 a64:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
 a68:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <wrongAttempts>
 a6c:	4a e0       	ldi	r20, 0x0A	; 10
 a6e:	be 01       	movw	r22, r28
 a70:	6f 5f       	subi	r22, 0xFF	; 255
 a72:	7f 4f       	sbci	r23, 0xFF	; 255
 a74:	90 e0       	ldi	r25, 0x00	; 0
 a76:	0e 94 b4 06 	call	0xd68	; 0xd68 <__itoa_ncheck>
	uart_puts(itoa(wrongAttempts, string2, 10));
 a7a:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
	uart_puts("\r\n");
 a7e:	85 ea       	ldi	r24, 0xA5	; 165
 a80:	91 e0       	ldi	r25, 0x01	; 1
 a82:	0e 94 a5 06 	call	0xd4a	; 0xd4a <uart_puts>
}
 a86:	0f 90       	pop	r0
 a88:	0f 90       	pop	r0
 a8a:	df 91       	pop	r29
 a8c:	cf 91       	pop	r28
 a8e:	08 95       	ret

00000a90 <comparePins>:

int8_t comparePins(char input[])
{
 a90:	1f 93       	push	r17
 a92:	cf 93       	push	r28
 a94:	df 93       	push	r29
 a96:	bc 01       	movw	r22, r24
	{
		// Compare 4-digit input pin with the registers pin
		// Ex. pi
		for(uint8_t b = 0; b<4; b++)
		{
			if(input[b] == pins[a][b])
 a98:	fc 01       	movw	r30, r24
 a9a:	10 81       	ld	r17, Z
 a9c:	ce e5       	ldi	r28, 0x5E	; 94
 a9e:	d2 e0       	ldi	r29, 0x02	; 2
{
	int8_t pinId = -1;	// Active pin ID, If -1 no active pins

	// Checking each registered pin
	// pins[0], pins[1], pins[2], pins[3]
	for(uint8_t a = 0; a<4; a++)
 aa0:	30 e0       	ldi	r19, 0x00	; 0
 aa2:	ac 01       	movw	r20, r24
 aa4:	4c 5f       	subi	r20, 0xFC	; 252
 aa6:	5f 4f       	sbci	r21, 0xFF	; 255
 aa8:	0e c0       	rjmp	.+28     	; 0xac6 <comparePins+0x36>
	{
		// Compare 4-digit input pin with the registers pin
		// Ex. pi
		for(uint8_t b = 0; b<4; b++)
		{
			if(input[b] == pins[a][b])
 aaa:	21 91       	ld	r18, Z+
 aac:	9d 91       	ld	r25, X+
 aae:	29 13       	cpse	r18, r25
 ab0:	06 c0       	rjmp	.+12     	; 0xabe <comparePins+0x2e>
	// pins[0], pins[1], pins[2], pins[3]
	for(uint8_t a = 0; a<4; a++)
	{
		// Compare 4-digit input pin with the registers pin
		// Ex. pi
		for(uint8_t b = 0; b<4; b++)
 ab2:	e4 17       	cp	r30, r20
 ab4:	f5 07       	cpc	r31, r21
 ab6:	c9 f7       	brne	.-14     	; 0xaaa <comparePins+0x1a>
		{
			if(input[b] == pins[a][b])
			{
				pinId = a;
 ab8:	83 2f       	mov	r24, r19
				pinId = -1;
				break;
			}
		}
		// If an active pin is found, stop comparing
		if(pinId != -1)
 aba:	3f 3f       	cpi	r19, 0xFF	; 255
 abc:	69 f4       	brne	.+26     	; 0xad8 <comparePins+0x48>
{
	int8_t pinId = -1;	// Active pin ID, If -1 no active pins

	// Checking each registered pin
	// pins[0], pins[1], pins[2], pins[3]
	for(uint8_t a = 0; a<4; a++)
 abe:	3f 5f       	subi	r19, 0xFF	; 255
 ac0:	24 96       	adiw	r28, 0x04	; 4
 ac2:	34 30       	cpi	r19, 0x04	; 4
 ac4:	41 f0       	breq	.+16     	; 0xad6 <comparePins+0x46>
	{
		// Compare 4-digit input pin with the registers pin
		// Ex. pi
		for(uint8_t b = 0; b<4; b++)
		{
			if(input[b] == pins[a][b])
 ac6:	98 81       	ld	r25, Y
 ac8:	19 13       	cpse	r17, r25
 aca:	f9 cf       	rjmp	.-14     	; 0xabe <comparePins+0x2e>
 acc:	fb 01       	movw	r30, r22
 ace:	31 96       	adiw	r30, 0x01	; 1
 ad0:	de 01       	movw	r26, r28
 ad2:	11 96       	adiw	r26, 0x01	; 1
 ad4:	ea cf       	rjmp	.-44     	; 0xaaa <comparePins+0x1a>
 ad6:	8f ef       	ldi	r24, 0xFF	; 255
		if(pinId != -1)
		break;
	}
	
	return pinId;
}
 ad8:	df 91       	pop	r29
 ada:	cf 91       	pop	r28
 adc:	1f 91       	pop	r17
 ade:	08 95       	ret

00000ae0 <__vector_16>:
}

/* Interrupt handlers ------------------------------------------------*/
// Interrupt Handler for scanning keypad, getting the typed pin and then compare the pin
ISR(TIMER0_OVF_vect)
{
 ae0:	1f 92       	push	r1
 ae2:	0f 92       	push	r0
 ae4:	0f b6       	in	r0, 0x3f	; 63
 ae6:	0f 92       	push	r0
 ae8:	11 24       	eor	r1, r1
 aea:	2f 93       	push	r18
 aec:	3f 93       	push	r19
 aee:	4f 93       	push	r20
 af0:	5f 93       	push	r21
 af2:	6f 93       	push	r22
 af4:	7f 93       	push	r23
 af6:	8f 93       	push	r24
 af8:	9f 93       	push	r25
 afa:	af 93       	push	r26
 afc:	bf 93       	push	r27
 afe:	ef 93       	push	r30
 b00:	ff 93       	push	r31
	volatile static char pressedKey = ' ';		// Pressed Key
	volatile static uint8_t pinDigitCnt = 0;	// Contains the index value of the pin
	volatile static uint8_t scanningStage = 0;	// Scanning Stage --> 0: None, 1: getPin, 2: Standby
	
	// Scan the Keypad
	pressedKey = keypad_scan();
 b02:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <keypad_scan>
 b06:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <pressedKey.2010>
	
	// Key Press Buzzer
	if(pressedKey != ' ')
 b0a:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b0e:	80 32       	cpi	r24, 0x20	; 32
 b10:	19 f0       	breq	.+6      	; 0xb18 <__vector_16+0x38>
		buzzerStage = 1;
 b12:	81 e0       	ldi	r24, 0x01	; 1
 b14:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <buzzerStage>
	
	// If user pressed #, ring the door bell
	if(pressedKey == '#' && scanningStage == 0)
 b18:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b1c:	83 32       	cpi	r24, 0x23	; 35
 b1e:	61 f4       	brne	.+24     	; 0xb38 <__vector_16+0x58>
 b20:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <scanningStage.2012>
 b24:	81 11       	cpse	r24, r1
 b26:	08 c0       	rjmp	.+16     	; 0xb38 <__vector_16+0x58>
	{
		ringDoorBell();
 b28:	0e 94 46 04 	call	0x88c	; 0x88c <ringDoorBell>
		// Wait 3s and then standby
		scanningStage = 2;
 b2c:	82 e0       	ldi	r24, 0x02	; 2
 b2e:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <scanningStage.2012>
		timerStage = 2;
 b32:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timerStage>
 b36:	19 c0       	rjmp	.+50     	; 0xb6a <__vector_16+0x8a>
	}
	// If user pressed *, configure the system to get typed pin
	else if(pressedKey == '*' && scanningStage == 0)
 b38:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b3c:	8a 32       	cpi	r24, 0x2A	; 42
 b3e:	a9 f4       	brne	.+42     	; 0xb6a <__vector_16+0x8a>
 b40:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <scanningStage.2012>
 b44:	81 11       	cpse	r24, r1
 b46:	11 c0       	rjmp	.+34     	; 0xb6a <__vector_16+0x8a>
	{
		scanningStage = 1;	// Enable getPin
 b48:	81 e0       	ldi	r24, 0x01	; 1
 b4a:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <scanningStage.2012>
		timerStage = 1;		// Start 5 second timer
 b4e:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timerStage>
		pinDigitCnt = 0;	// Set pin input index to 0
 b52:	10 92 70 02 	sts	0x0270, r1	; 0x800270 <pinDigitCnt.2011>
						
		// Configure lcd
		lcd_clrscr();
 b56:	0e 94 a1 01 	call	0x342	; 0x342 <lcd_clrscr>
		lcd_gotoxy(2,1);
 b5a:	61 e0       	ldi	r22, 0x01	; 1
 b5c:	82 e0       	ldi	r24, 0x02	; 2
 b5e:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
		lcd_puts("--Enter the pin--");
 b62:	88 e1       	ldi	r24, 0x18	; 24
 b64:	92 e0       	ldi	r25, 0x02	; 2
 b66:	0e 94 a9 01 	call	0x352	; 0x352 <lcd_puts>
	}
		
	// If scanningStage is 1 get the typed pin
	if(scanningStage == 1)
 b6a:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <scanningStage.2012>
 b6e:	81 30       	cpi	r24, 0x01	; 1
 b70:	09 f0       	breq	.+2      	; 0xb74 <__vector_16+0x94>
 b72:	45 c0       	rjmp	.+138    	; 0xbfe <__vector_16+0x11e>
	{
		// Scan the entered pin
		if(pressedKey != '*' && pressedKey != '#' && pressedKey!= ' ')
 b74:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b78:	8a 32       	cpi	r24, 0x2A	; 42
 b7a:	f1 f0       	breq	.+60     	; 0xbb8 <__vector_16+0xd8>
 b7c:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b80:	83 32       	cpi	r24, 0x23	; 35
 b82:	d1 f0       	breq	.+52     	; 0xbb8 <__vector_16+0xd8>
 b84:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b88:	80 32       	cpi	r24, 0x20	; 32
 b8a:	b1 f0       	breq	.+44     	; 0xbb8 <__vector_16+0xd8>
		{
			// Put the pressed key into inputPin var
			inPin[pinDigitCnt] = pressedKey;
 b8c:	e0 91 70 02 	lds	r30, 0x0270	; 0x800270 <pinDigitCnt.2011>
 b90:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <pressedKey.2010>
 b94:	f0 e0       	ldi	r31, 0x00	; 0
 b96:	eb 5d       	subi	r30, 0xDB	; 219
 b98:	fe 4f       	sbci	r31, 0xFE	; 254
 b9a:	80 83       	st	Z, r24
				
			// Configure lcd
			lcd_gotoxy((pinDigitCnt + 8),2);
 b9c:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <pinDigitCnt.2011>
 ba0:	62 e0       	ldi	r22, 0x02	; 2
 ba2:	88 5f       	subi	r24, 0xF8	; 248
 ba4:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_gotoxy>
			lcd_putc('*');
 ba8:	8a e2       	ldi	r24, 0x2A	; 42
 baa:	0e 94 a5 01 	call	0x34a	; 0x34a <lcd_putc>
				
			// Increase the counter
			pinDigitCnt++;
 bae:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <pinDigitCnt.2011>
 bb2:	8f 5f       	subi	r24, 0xFF	; 255
 bb4:	80 93 70 02 	sts	0x0270, r24	; 0x800270 <pinDigitCnt.2011>
		}
		
		// If 5s is up or the user typed all the digits of the pin enter here
		// and compare typed pin with the correct ones
		if(timerStage == 0 || pinDigitCnt > 3)
 bb8:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timerStage>
 bbc:	88 23       	and	r24, r24
 bbe:	21 f0       	breq	.+8      	; 0xbc8 <__vector_16+0xe8>
 bc0:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <pinDigitCnt.2011>
 bc4:	84 30       	cpi	r24, 0x04	; 4
 bc6:	40 f1       	brcs	.+80     	; 0xc18 <__vector_16+0x138>
		{	
			// Compare the typed pin and the correct pins
			inID = comparePins(inPin);
 bc8:	85 e2       	ldi	r24, 0x25	; 37
 bca:	91 e0       	ldi	r25, 0x01	; 1
 bcc:	0e 94 48 05 	call	0xa90	; 0xa90 <comparePins>
 bd0:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <inID>
			
			// If user typed pin before the timer finish stop the timer			
			timerStage = 0;
 bd4:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <timerStage>
			timerCnt = 0;
 bd8:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <timerCnt>
			
			// Typed pin is incorrect
			if(inID == -1)
 bdc:	8f 3f       	cpi	r24, 0xFF	; 255
 bde:	19 f4       	brne	.+6      	; 0xbe6 <__vector_16+0x106>
			{
				wrongPin();
 be0:	0e 94 ed 04 	call	0x9da	; 0x9da <wrongPin>
 be4:	04 c0       	rjmp	.+8      	; 0xbee <__vector_16+0x10e>
			}
			// Typed pin is correct
			else if(inID >= 0 && inID < 4)
 be6:	84 30       	cpi	r24, 0x04	; 4
 be8:	10 f4       	brcc	.+4      	; 0xbee <__vector_16+0x10e>
			{
				correctPin(inID);
 bea:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <correctPin>
			}
		
			pinDigitCnt = 0;
 bee:	10 92 70 02 	sts	0x0270, r1	; 0x800270 <pinDigitCnt.2011>
			// Wait 3s then, configure system for standby stage
			scanningStage = 2;
 bf2:	82 e0       	ldi	r24, 0x02	; 2
 bf4:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <scanningStage.2012>
			timerStage = 2;
 bf8:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timerStage>
 bfc:	0d c0       	rjmp	.+26     	; 0xc18 <__vector_16+0x138>
		}
	}
	
	// Changing the status to the standby
	if(scanningStage == 2)
 bfe:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <scanningStage.2012>
 c02:	82 30       	cpi	r24, 0x02	; 2
 c04:	59 f4       	brne	.+22     	; 0xc1c <__vector_16+0x13c>
	{
		if(timerStage == 0)
 c06:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timerStage>
 c0a:	81 11       	cpse	r24, r1
 c0c:	07 c0       	rjmp	.+14     	; 0xc1c <__vector_16+0x13c>
		{
			scanningStage = 0;
 c0e:	10 92 71 02 	sts	0x0271, r1	; 0x800271 <scanningStage.2012>
			standby();
 c12:	0e 94 99 03 	call	0x732	; 0x732 <standby>
		}
	}
}
 c16:	02 c0       	rjmp	.+4      	; 0xc1c <__vector_16+0x13c>
			timerStage = 2;
		}
	}
	
	// Changing the status to the standby
	if(scanningStage == 2)
 c18:	80 91 71 02 	lds	r24, 0x0271	; 0x800271 <scanningStage.2012>
		{
			scanningStage = 0;
			standby();
		}
	}
}
 c1c:	ff 91       	pop	r31
 c1e:	ef 91       	pop	r30
 c20:	bf 91       	pop	r27
 c22:	af 91       	pop	r26
 c24:	9f 91       	pop	r25
 c26:	8f 91       	pop	r24
 c28:	7f 91       	pop	r23
 c2a:	6f 91       	pop	r22
 c2c:	5f 91       	pop	r21
 c2e:	4f 91       	pop	r20
 c30:	3f 91       	pop	r19
 c32:	2f 91       	pop	r18
 c34:	0f 90       	pop	r0
 c36:	0f be       	out	0x3f, r0	; 63
 c38:	0f 90       	pop	r0
 c3a:	1f 90       	pop	r1
 c3c:	18 95       	reti

00000c3e <__vector_18>:
    /* store buffer index */
    UART_RxTail = tmptail;

    UART_LastRxError = 0;
    return (lastRxError << 8) + data;
}/* uart_getc */
 c3e:	1f 92       	push	r1
 c40:	0f 92       	push	r0
 c42:	0f b6       	in	r0, 0x3f	; 63
 c44:	0f 92       	push	r0
 c46:	11 24       	eor	r1, r1
 c48:	2f 93       	push	r18
 c4a:	8f 93       	push	r24
 c4c:	9f 93       	push	r25
 c4e:	ef 93       	push	r30
 c50:	ff 93       	push	r31
 c52:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 c56:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 c5a:	8c 71       	andi	r24, 0x1C	; 28
 c5c:	e0 91 79 02 	lds	r30, 0x0279	; 0x800279 <UART_RxHead>
 c60:	ef 5f       	subi	r30, 0xFF	; 255
 c62:	ef 77       	andi	r30, 0x7F	; 127
 c64:	90 91 78 02 	lds	r25, 0x0278	; 0x800278 <UART_RxTail>
 c68:	e9 17       	cp	r30, r25
 c6a:	39 f0       	breq	.+14     	; 0xc7a <__vector_18+0x3c>
 c6c:	e0 93 79 02 	sts	0x0279, r30	; 0x800279 <UART_RxHead>
 c70:	f0 e0       	ldi	r31, 0x00	; 0
 c72:	e4 58       	subi	r30, 0x84	; 132
 c74:	fd 4f       	sbci	r31, 0xFD	; 253
 c76:	20 83       	st	Z, r18
 c78:	01 c0       	rjmp	.+2      	; 0xc7c <__vector_18+0x3e>
 c7a:	82 e0       	ldi	r24, 0x02	; 2
 c7c:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <UART_LastRxError>
 c80:	89 2b       	or	r24, r25
 c82:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <UART_LastRxError>
 c86:	ff 91       	pop	r31
 c88:	ef 91       	pop	r30
 c8a:	9f 91       	pop	r25
 c8c:	8f 91       	pop	r24
 c8e:	2f 91       	pop	r18
 c90:	0f 90       	pop	r0
 c92:	0f be       	out	0x3f, r0	; 63
 c94:	0f 90       	pop	r0
 c96:	1f 90       	pop	r1
 c98:	18 95       	reti

00000c9a <__vector_19>:
 c9a:	1f 92       	push	r1
 c9c:	0f 92       	push	r0
 c9e:	0f b6       	in	r0, 0x3f	; 63
 ca0:	0f 92       	push	r0
 ca2:	11 24       	eor	r1, r1
 ca4:	8f 93       	push	r24
 ca6:	9f 93       	push	r25
 ca8:	ef 93       	push	r30
 caa:	ff 93       	push	r31
 cac:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <UART_TxHead>
 cb0:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <UART_TxTail>
 cb4:	98 17       	cp	r25, r24
 cb6:	69 f0       	breq	.+26     	; 0xcd2 <__vector_19+0x38>
 cb8:	e0 91 7a 02 	lds	r30, 0x027A	; 0x80027a <UART_TxTail>
 cbc:	ef 5f       	subi	r30, 0xFF	; 255
 cbe:	ef 77       	andi	r30, 0x7F	; 127
 cc0:	e0 93 7a 02 	sts	0x027A, r30	; 0x80027a <UART_TxTail>
 cc4:	f0 e0       	ldi	r31, 0x00	; 0
 cc6:	e4 50       	subi	r30, 0x04	; 4
 cc8:	fd 4f       	sbci	r31, 0xFD	; 253
 cca:	80 81       	ld	r24, Z
 ccc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 cd0:	05 c0       	rjmp	.+10     	; 0xcdc <__vector_19+0x42>
 cd2:	e1 ec       	ldi	r30, 0xC1	; 193
 cd4:	f0 e0       	ldi	r31, 0x00	; 0
 cd6:	80 81       	ld	r24, Z
 cd8:	8f 7d       	andi	r24, 0xDF	; 223
 cda:	80 83       	st	Z, r24
 cdc:	ff 91       	pop	r31
 cde:	ef 91       	pop	r30
 ce0:	9f 91       	pop	r25
 ce2:	8f 91       	pop	r24
 ce4:	0f 90       	pop	r0
 ce6:	0f be       	out	0x3f, r0	; 63
 ce8:	0f 90       	pop	r0
 cea:	1f 90       	pop	r1
 cec:	18 95       	reti

00000cee <uart_init>:
 cee:	10 92 7b 02 	sts	0x027B, r1	; 0x80027b <UART_TxHead>
 cf2:	10 92 7a 02 	sts	0x027A, r1	; 0x80027a <UART_TxTail>
 cf6:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <UART_RxHead>
 cfa:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <UART_RxTail>
 cfe:	99 23       	and	r25, r25
 d00:	1c f4       	brge	.+6      	; 0xd08 <uart_init+0x1a>
 d02:	22 e0       	ldi	r18, 0x02	; 2
 d04:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 d08:	90 78       	andi	r25, 0x80	; 128
 d0a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
 d0e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
 d12:	88 e9       	ldi	r24, 0x98	; 152
 d14:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
 d18:	86 e0       	ldi	r24, 0x06	; 6
 d1a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
 d1e:	08 95       	ret

00000d20 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;


    tmphead = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 d20:	20 91 7b 02 	lds	r18, 0x027B	; 0x80027b <UART_TxHead>
 d24:	2f 5f       	subi	r18, 0xFF	; 255
 d26:	2f 77       	andi	r18, 0x7F	; 127

    while (tmphead == UART_TxTail)
 d28:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <UART_TxTail>
 d2c:	29 17       	cp	r18, r25
 d2e:	e1 f3       	breq	.-8      	; 0xd28 <uart_putc+0x8>
    {
        ;/* wait for free space in buffer */
    }

    UART_TxBuf[tmphead] = data;
 d30:	e2 2f       	mov	r30, r18
 d32:	f0 e0       	ldi	r31, 0x00	; 0
 d34:	e4 50       	subi	r30, 0x04	; 4
 d36:	fd 4f       	sbci	r31, 0xFD	; 253
 d38:	80 83       	st	Z, r24
    UART_TxHead         = tmphead;
 d3a:	20 93 7b 02 	sts	0x027B, r18	; 0x80027b <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL |= _BV(UART0_UDRIE);
 d3e:	e1 ec       	ldi	r30, 0xC1	; 193
 d40:	f0 e0       	ldi	r31, 0x00	; 0
 d42:	80 81       	ld	r24, Z
 d44:	80 62       	ori	r24, 0x20	; 32
 d46:	80 83       	st	Z, r24
 d48:	08 95       	ret

00000d4a <uart_puts>:
 * Purpose:  transmit string to UART
 * Input:    string to be transmitted
 * Returns:  none
 **************************************************************************/
void uart_puts(const char *s)
{
 d4a:	cf 93       	push	r28
 d4c:	df 93       	push	r29
 d4e:	ec 01       	movw	r28, r24
    while (*s)
 d50:	88 81       	ld	r24, Y
 d52:	88 23       	and	r24, r24
 d54:	31 f0       	breq	.+12     	; 0xd62 <uart_puts+0x18>
 d56:	21 96       	adiw	r28, 0x01	; 1
        uart_putc(*s++);
 d58:	0e 94 90 06 	call	0xd20	; 0xd20 <uart_putc>
 * Input:    string to be transmitted
 * Returns:  none
 **************************************************************************/
void uart_puts(const char *s)
{
    while (*s)
 d5c:	89 91       	ld	r24, Y+
 d5e:	81 11       	cpse	r24, r1
 d60:	fb cf       	rjmp	.-10     	; 0xd58 <uart_puts+0xe>
        uart_putc(*s++);
}/* uart_puts */
 d62:	df 91       	pop	r29
 d64:	cf 91       	pop	r28
 d66:	08 95       	ret

00000d68 <__itoa_ncheck>:
 d68:	bb 27       	eor	r27, r27
 d6a:	4a 30       	cpi	r20, 0x0A	; 10
 d6c:	31 f4       	brne	.+12     	; 0xd7a <__itoa_ncheck+0x12>
 d6e:	99 23       	and	r25, r25
 d70:	22 f4       	brpl	.+8      	; 0xd7a <__itoa_ncheck+0x12>
 d72:	bd e2       	ldi	r27, 0x2D	; 45
 d74:	90 95       	com	r25
 d76:	81 95       	neg	r24
 d78:	9f 4f       	sbci	r25, 0xFF	; 255
 d7a:	0c 94 c0 06 	jmp	0xd80	; 0xd80 <__utoa_common>

00000d7e <__utoa_ncheck>:
 d7e:	bb 27       	eor	r27, r27

00000d80 <__utoa_common>:
 d80:	fb 01       	movw	r30, r22
 d82:	55 27       	eor	r21, r21
 d84:	aa 27       	eor	r26, r26
 d86:	88 0f       	add	r24, r24
 d88:	99 1f       	adc	r25, r25
 d8a:	aa 1f       	adc	r26, r26
 d8c:	a4 17       	cp	r26, r20
 d8e:	10 f0       	brcs	.+4      	; 0xd94 <__utoa_common+0x14>
 d90:	a4 1b       	sub	r26, r20
 d92:	83 95       	inc	r24
 d94:	50 51       	subi	r21, 0x10	; 16
 d96:	b9 f7       	brne	.-18     	; 0xd86 <__utoa_common+0x6>
 d98:	a0 5d       	subi	r26, 0xD0	; 208
 d9a:	aa 33       	cpi	r26, 0x3A	; 58
 d9c:	08 f0       	brcs	.+2      	; 0xda0 <__utoa_common+0x20>
 d9e:	a9 5d       	subi	r26, 0xD9	; 217
 da0:	a1 93       	st	Z+, r26
 da2:	00 97       	sbiw	r24, 0x00	; 0
 da4:	79 f7       	brne	.-34     	; 0xd84 <__utoa_common+0x4>
 da6:	b1 11       	cpse	r27, r1
 da8:	b1 93       	st	Z+, r27
 daa:	11 92       	st	Z+, r1
 dac:	cb 01       	movw	r24, r22
 dae:	0c 94 d9 06 	jmp	0xdb2	; 0xdb2 <strrev>

00000db2 <strrev>:
 db2:	dc 01       	movw	r26, r24
 db4:	fc 01       	movw	r30, r24
 db6:	67 2f       	mov	r22, r23
 db8:	71 91       	ld	r23, Z+
 dba:	77 23       	and	r23, r23
 dbc:	e1 f7       	brne	.-8      	; 0xdb6 <strrev+0x4>
 dbe:	32 97       	sbiw	r30, 0x02	; 2
 dc0:	04 c0       	rjmp	.+8      	; 0xdca <strrev+0x18>
 dc2:	7c 91       	ld	r23, X
 dc4:	6d 93       	st	X+, r22
 dc6:	70 83       	st	Z, r23
 dc8:	62 91       	ld	r22, -Z
 dca:	ae 17       	cp	r26, r30
 dcc:	bf 07       	cpc	r27, r31
 dce:	c8 f3       	brcs	.-14     	; 0xdc2 <strrev+0x10>
 dd0:	08 95       	ret

00000dd2 <_exit>:
 dd2:	f8 94       	cli

00000dd4 <__stop_program>:
 dd4:	ff cf       	rjmp	.-2      	; 0xdd4 <__stop_program>
